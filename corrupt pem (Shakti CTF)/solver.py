#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Rebuild q via CRT, form n, decrypt decimal ciphertext, print FULL plaintext,
then extract and print the CTF flag (prefix + braces).
"""

import re

def ih(hex_or_0x_str: str) -> int:
    s = hex_or_0x_str.strip().lower().replace("\n", "").replace(" ", "")
    if s.startswith("0x"):
        s = s[2:]
    return int(s, 16)

def invmod(a: int, m: int) -> int:
    try:
        return pow(a, -1, m)
    except ValueError:
        # Extended Euclidean algorithm
        t, new_t = 0, 1
        r, new_r = m, a % m
        while new_r:
            q = r // new_r
            t, new_t = new_t, t - q * new_t
            r, new_r = new_r, r - q * new_r
        if r != 1:
            raise ValueError("No inverse exists")
        return t % m

def crt_two(r1: int, m1: int, r2: int, m2: int) -> int:
    # x = r1 + m1 * ((r2 - r1) * (m1^{-1} mod m2) mod m2)
    inv_m1_mod_m2 = invmod(m1 % m2, m2)
    t = ((r2 - r1) % m2) * inv_m1_mod_m2 % m2
    return r1 + m1 * t

# ==== Provided data ====
lower_n = ih("""
6463395ca1b63be1279cd97694ade51927267ae45c70e736c3f130109c0a0b6e55458eece2ba8fa8e6111a07dd290ca82bbea2a7423232242663d92cab0c75b524a7e32ac602ef42a2f853cc920ef086be259c0674b66bf48deb7d
""")

e = ih("0x010001")

d = ih("""
7b6da188fa79a30e377cf4075b884890481f0456a2da1da02098c6ac1a7a856d93577393abafa57c1ad98347a5d3abc3074cc79da804249d592903e0e5dc2785adcff39f22b742db76e4f4f6acabdb5110594ae45d0f04e60ad138c14ee1595298250193406e91d281f299dc38493e1668cb5ba8806da7429908d3a835eb59f99d9fd4b2bb736ce96aff288958429225b4898f1041e20df2326c0f38873f5c1faee1f9dc9bb11789d1938d657eab65844d42816267804839cdf850a9bd96ece2754b2c860c3918ccd5e458c3763a977771114906e9973e027e83cbfcea431e95e40dc71989587c69ab2fb15238b99bf59abee645785bbea8e916aff0a71bc3e5ac01fac251a938d08a75115058c2791b7cbe330741ced906067332a4f7522ceaa22388623637874008f53fb817f0a759459a7c76980fcf219b8ce0774e9cd83c42296387e6a16f1d36b6ad3b45d7b5f21e0ff3db87667a4668b8df70db920a595c9e84d994f8641446b42cd28b935210a3bb07e5c4d761ad27d9e0f82985f294299e493d7743a27954a27568c35623f9714950e88d44f46f5b018894580e9e4aa53198165f2b22c0578cc5ea26b4590665a2938d637215752cd9419c6e792b18e3c209b1e7bb7e853c27cc0ac4bde5a660e924853b5272ee3625283248385286a55c7c4dce23e8ba21335f6ae20c3b66a32438099ab3e2c908f38fa4f2d4b8ed
""")

p = ih("""
00c58125e91517431fe7cbbdab0b201a9c2d39d9112b27ab2e8d0715129d839261413076917aac66225e6256638843b10b7c4b79c38d9dce4b7ef04b9fae7df651b884f1a524cb9da4af083ecc350b45c19bccedf6f8cf06a362dfc4c214f85a4a3fcc5561851e783713ef79afc8126b8df769419195e304c094fec624157e1b7bbccafe8c627e37cbb210bdf50eeb4852293b2e4e1c7d1710237b9f60c206820b431f3ca983e30cdec56412657d14b478040753d4b861727ad63238a09cb756195995bf0bd68792b42666fd00ddbb82951d6b8a9e9024a68caad139295325389c75dd5a5da7605c110ddeadb79206cddc35a124c92483027b91d205ab47f8992b
""")

upper_q = ih("00a57d38a663751e483eae0d91f89a46e0e3abcfa86ee9370890fe44597e579377ec6b")
lower_q = ih("c91ba6f3713fa6527fc49ca202c4d1c1adebe100b12b917cab89c7dee9f7")

qInv = ih("""
6c9005d23c5e5bc8da1f860613623d68080cb8acb717019f485713bb5747f6647e980f161cbbf5457a237597df6d27b60af99fdb6ae52d29ce496bd9e677408b073e553b07aa25ad0d70f3d863a1c58a32f48fb5020972c52a5da0a51f0b159ec5d83c233ec4d2cab6d898d6e3a0344636e1d4113d0249151c797fc4aa79a4e28cf681aea2f602bb7dca6663ba83435bf68c1cc9d5df44fae9755fde9a266a22c879c163c9a04e849ce8dbea75043c9dd3e9b823e4127fe828c010949b91461f4eb37df48861497f6d91079d65ab7cfeaed7095ddeccdf4c8224262ac3688801e3822f872e230d5875ef56bfff70b60142b1f2a8783830d9d2398887a2d7d13b
""")

cipher_dec = int(
"327836414797988169756593626732132094675086111149108410679618658497225787491272816844192064175689466465027535995236809754982811291894856362817469623510785963738591433845315548033914642616896304091023276158650296799873124105811387920618383206475930184291454194085034760253361175836127905061222610891384571132159547538523406564828146697237048149650859235156261113070378673866519537888968338317925393165910235203301328740387030571895412108295398288551486143426808530054247460275274097125191879870925165232754091286707568202843754796235359292129404241951946617840815346033247824570202210994934888848176271657683993834014676382130384380760494817703814894769008651586621472914586754718876242512987987353302017040907910716199366364753496922112519263648649354719498462656439374799847954454770014127394441938942489409851182965349189072599138311890036597627200383041792046672430910737637005155089266350033457158833727075262690254601990950072400432823080446573816383998949508346643309269321161101237730894885040047759984778400121232035239079135111942861073510836099588802805473180341827189332824841713728810150060189053991497159269614561635929107928489043946106528416643002185097925991538252568045016401267769507832815666815478899598321424282195"
)

# ==== Reconstruct q via CRT ====
L = lower_n.bit_length()
mod2L = 1 << L

# q ≡ b (mod 2^L)
p_inv_mod_2L = invmod(p % mod2L, mod2L)
b = (lower_n * p_inv_mod_2L) % mod2L

# q ≡ a (mod p), where a = qInv^{-1} (mod p)
a = invmod(qInv, p)

# Combine (coprime moduli)
q = crt_two(a, p, b, mod2L)

# Optional sanity checks
assert (q & ((1 << lower_q.bit_length()) - 1)) == lower_q, "lower_q mismatch"
topU = q >> (q.bit_length() - upper_q.bit_length())
assert topU == upper_q, "upper_q mismatch"
assert (p * q) % mod2L == lower_n, "lower_n mismatch with p*q"

# Build modulus and decrypt
n = p * q
m = pow(cipher_dec, d, n)

# Convert to fixed-length bytes
klen = (n.bit_length() + 7) // 8
m_bytes = m.to_bytes(klen, "big")

# Try PKCS#1 v1.5 unpadding if present; else take raw
if klen > 11 and m_bytes[:2] == b"\x00\x02":
    sep = m_bytes.find(b"\x00", 2)
    core = m_bytes[sep+1:] if sep != -1 else m_bytes
else:
    core = m_bytes

plaintext = core.decode("latin1", "ignore")
print("PLAINTEXT:")
print(plaintext)

# Extract the flag with prefix (e.g., shaktictf{...})
mflag = re.search(r'[A-Za-z][A-Za-z0-9_]{1,31}\{[^}\n]+\}', plaintext)
if mflag:
    print("\nFLAG:")
    print(mflag.group(0))

